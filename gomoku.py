import numpy as np
from state import State
from utils import pattern_search
import time
from numba import njit

# TODO: Implement Pattern Class. And sub-class Threat? Direction as a property?
# TODO: Implement code to identify and return said pattern?

# TODO: Finish up state initialization procedures.
# TODO: List all threats including relevant permutations.
# TODO: Including the threats, define the winning patterns(look at the edge cases as well!)
# TODO: To differentiate between standard and freestyle gomoku, can we just rely on the win patterns?
# TODO: Control freestyle or standard via a global variable? Or better to do via state?
# TODO: Looking into what other pattern_search functions we need.
# TODO: We need at least the threats/(new threats?) generated by a given move.
# TODO: Identify duplicate threats along the same direction by the same move!
# TODO: Duplicate point is relevant, especially when we allow freestyle!
# TODO: Rich state data structures?
# TODO: Do we need to always get the side of the board? Can't we just assume it to be size?

state = State()

a1 = np.array([0, 1, 1, 1, 1, -1], dtype=np.byte)

for i in range(0, 4):
    state.board[0][10 + i] = 1

state.board[0][14] = -1

print(pattern_search(state.board, a1, 1, True))




# @njit
# def test_fn(board, pattern, n):
#     for _ in range(n):
#         pattern_search(board, pattern, 1, True)


# n = 1000000
# test_fn(state.board, a1, n)

# start = time.monotonic()
# test_fn(state.board, a1, n)
# end = time.monotonic()

# print("Time taken: ", end - start, " seconds")
