import numpy as np
import time
from state import State
from utils import pattern_search
from numba import njit
from consts import OWN, EMPTY, BLACK, WHITE, NOT_OWN


# TODO: Create tests and profiling fns for pattern_search.

# TODO: Implement Pattern Class. And sub-class Threat? Direction as a property?
# TODO: Implement code to identify and return said pattern?

# TODO: Finish up state initialization procedures.
# TODO: List all threats including relevant permutations.
# TODO: Including the threats, define the winning patterns(look at the edge cases as well!)
# TODO: To differentiate between standard and freestyle gomoku, can we just rely on the win patterns?
# TODO: Control freestyle or standard via a global variable? Or better to do via state?
# TODO: Looking into what other pattern_search functions we need.
# TODO: We need at least the threats/(new threats?) generated by a given move.
# TODO: Identify duplicate threats along the same direction by the same move!
# TODO: Duplicate point is relevant, especially when we allow freestyle!
# TODO: Rich state data structures?
# TODO: Do we need to always get the side of the board? Can't we just assume it to be size?

# TODO: Inline numba jitted functions?
# TODO: Cleanup import statements.
# TODO: Remove unnecessary asserts.

state = State()
# pattern = np.array([EMPTY, OWN, OWN, OWN, OWN, NOT_OWN], dtype=np.byte)
pattern = np.array([NOT_OWN, OWN, OWN, OWN, OWN, NOT_OWN], dtype=np.byte)
color = WHITE

for i in range(0, 4):
    state.board[1][11 + i] = color
    state.board[15 - i][12 + i] = color
    state.board[15 - i][15 - i] = color

print(state.board)
print(pattern)
print(pattern_search(state.board, pattern, color))


# @njit
# def test_fn(board, pattern, n):
#     for _ in range(n):
#         pattern_search(board, pattern, color)


# n = 1000000
# test_fn(state.board, pattern, n)

# start = time.monotonic()
# test_fn(state.board, pattern, n)
# end = time.monotonic()

# print("Time taken: ", end - start, " seconds")
